.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.3.
.TH E "1" "May 2024" "E 3.1.0 Singbulli (9f241907de1b136dec0e1e1ac55db56c724c387a)" "User Commands"
.SH NAME
E \- manual page for E 3.1.0 Singbulli (9f241907de1b136dec0e1e1ac55db56c724c387a)
.SH SYNOPSIS
.B eprover
[\fI\,options\/\fR] [\fI\,files\/\fR]
.SH DESCRIPTION
E 3.1.0 "Singbulli"
.PP
Read a set of first\-order clauses and formulae and try to refute it.
.SH OPTIONS
.HP
\fB\-h\fR
.HP
\fB\-\-help\fR
.IP
Print a short description of program usage and options.
.HP
\fB\-V\fR
.HP
\fB\-\-version\fR
.IP
Print the version number of the prover. Please include this with all bug
reports (if any).
.HP
\fB\-v\fR
.HP
\fB\-\-verbose[=\fR<arg>]
.IP
Verbose comments on the progress of the program. This differs from the
output level (below) in that technical information is printed to stderr,
while the output level determines which logical manipulations of the
clauses are printed to stdout. The short form or the long form without
the optional argument is equivalent to \fB\-\-verbose\fR=\fI\,1\/\fR.
.HP
\fB\-o\fR <arg>
.HP
\fB\-\-output\-file=\fR<arg>
.IP
Redirect output into the named file.
.HP
\fB\-s\fR
.HP
\fB\-\-silent\fR
.IP
Equivalent to \fB\-\-output\-level\fR=\fI\,0\/\fR.
.HP
\fB\-l\fR <arg>
.HP
\fB\-\-output\-level=\fR<arg>
.IP
Select an output level, greater values imply more verbose output. Level 0
produces nearly no output, level 1 will output each clause as it is
processed, level 2 will output generating inferences, level 3 will give a
full protocol including rewrite steps and level 4 will include some
internal clause renamings. Levels >= 2 also imply PCL2 or TSTP formats
(which can be post\-processed with suitable tools).
.HP
\fB\-p\fR
.HP
\fB\-\-proof\-object[=\fR<arg>]
.IP
Generate (and print, in case of success) an internal proof object. Level
0 will not print a proof object, level 1 will build asimple, compact
proof object that only contains inference rules and dependencies, level 2
will build a proof object where inferences are unambiguously described by
giving inference positions, and level 3 will expand this to a proof
object where all intermediate results are explicit. This feature is under
development, so far only level 0 and 1 are operational. By default The
proof object will be provided in TPTP\-3 or LOP syntax, depending on input
format and explicit settings. The following option will suppress normal
output of the proof object in favour of a graphial representation. The
short form or the long form without the optional argument is equivalent
to \fB\-\-proof\-object\fR=\fI\,1\/\fR.
.HP
\fB\-\-proof\-statistics\fR
.IP
Print various statistics of the proof object.
.HP
\fB\-\-proof\-graph[=\fR<arg>]
.IP
Generate (and print, in case of success) an internal proof object in the
form of a GraphViz dot graph. The optional argument can be 1 (nodes are
labelled with just the name of the clause/formula), 2 (nodes are labelled
with the TPTP clause/formula) or 3  (nodes also labelled with
source/inference record. The option without the optional argument is
equivalent to \fB\-\-proof\-graph\fR=\fI\,3\/\fR.
.HP
\fB\-d\fR
.HP
\fB\-\-full\-deriv\fR
.IP
Include all derived formuas/clauses in the proof graph/proof object, not
just the ones contributing to the actual proof.
.HP
\fB\-\-force\-deriv[=\fR<arg>]
.IP
Force output of the derivation even in cases where the prover terminates
in an indeterminate state. By default, the deriviation of all processed
clauses is included in the derivation object. With argument 2, the
derivation of all clauses will be printed. The option without the
optional argument is equivalent to \fB\-\-force\-deriv\fR=\fI\,1\/\fR.
.HP
\fB\-\-record\-gcs\fR
.IP
Record given\-clause selection as separate (pseudo\-)inferences and
preserve the form of given clauses evaluated and selected via archiving
for analysis and possibly machine learning.
.HP
\fB\-\-training\-examples[=\fR<arg>]
.IP
Generate and process training examples from the proof search object.
Implies \fB\-\-record\-gcs\fR. The argument is a binary or of the desired
processing. Bit zero prints positive exampels. Bit 1 prints negative
examples. Additional selectors will be added later. The option without
the optional argument is equivalent to \fB\-\-training\-examples\fR=\fI\,1\/\fR.
.HP
\fB\-\-pcl\-terms\-compressed\fR
.IP
Print terms in the PCL output in shared representation.
.HP
\fB\-\-pcl\-compact\fR
.IP
Print PCL steps without additional spaces for formatting (safes disk
space for large protocols).
.HP
\fB\-\-pcl\-shell\-level[=\fR<arg>]
.IP
Determines level to which clauses and formulas are suppressed in the
output. Level 0 will print all, level 1 will only print initial
clauses/formulas, level 2 will print no clauses or axioms. All levels
will still print the dependency graph. The option without the optional
argument is equivalent to \fB\-\-pcl\-shell\-level\fR=\fI\,1\/\fR.
.HP
\fB\-\-print\-statistics\fR
.IP
Print the inference statistics (only relevant for output level <=1,
otherwise they are printed automatically.
.HP
\fB\-0\fR
.HP
\fB\-\-print\-detailed\-statistics\fR
.IP
Print data about the proof state that is potentially expensive to
collect. Includes number of term cells and number of rewrite steps. This
implies the previous option.
.HP
\fB\-S\fR
.HP
\fB\-\-print\-saturated[=\fR<arg>]
.IP
Print the (semi\-) saturated clause sets after terminating the saturation
process. The argument given describes which parts should be printed in
which order. Legal characters are 'teigEIGaA', standing for type
declarations, processed positive units, processed negative units,
processed non\-units, unprocessed positive units, unprocessed negative
units, unprocessed non\-units, and two types of additional equality
axioms, respectively. Equality axioms will only be printed if the
original specification contained real equality. In this case, 'a'
requests axioms in which a separate substitutivity axiom is given for
each argument position of a function or predicate symbol, while 'A'
requests a single substitutivity axiom (covering all positions) for each
symbol. The short form or the long form without the optional argument is
equivalent to \fB\-\-print\-saturated\fR=\fI\,eigEIG\/\fR.
.HP
\fB\-\-print\-sat\-info\fR
.IP
Print additional information (clause number, weight, etc) as a comment
for clauses from the semi\-saturated end system.
.HP
\fB\-\-filter\-saturated[=\fR<arg>]
.TP
Filter the
(semi\-) saturated clause sets after terminating the
.IP
saturation process. The argument is a string describing which operations
to take (and in which order). Options are 'u' (remove all clauses with
more than one literal), 'c' (delete all but one copy of identical
clauses, 'n', 'r', 'f' (forward contraction, unit\-subsumption only, no
rewriting, rewriting with rules only, full rewriting, respectively), and
\&'N', 'R' and 'F' (as their lower case counterparts, but with
non\-unit\-subsumption enabled as well). The option without the optional
argument is equivalent to \fB\-\-filter\-saturated\fR=\fI\,Fc\/\fR.
.HP
\fB\-\-syntax\-only\fR
.IP
Stop after parsing, i.e. only check if the input can be parsed correcly.
.HP
\fB\-\-prune\fR
.IP
Stop after relevancy pruning, SInE pruning, and output of the initial
clause\- and formula set. This will automatically set output level to 4 so
that the pruned problem specification is printed. Note that the desired
pruning methods must still be specified (e.g. '\-\-sine=Auto').
.HP
\fB\-\-cnf\fR
.IP
Convert the input problem into clause normal form and print it. This is
(nearly) equivalent to '\-\-print\-saturated=eigEIG
\fB\-\-processed\-clauses\-limit\fR=\fI\,0\/\fR' and will by default perform some usually
useful simplifications. You can additionally specify e.g.
\&'\-\-no\-preprocessing' if you want just the result of CNF translation.
.HP
\fB\-\-print\-pid\fR
.IP
Print the process id of the prover as a comment after option processing.
.HP
\fB\-\-print\-version\fR
.IP
Print the version number of the prover as a comment after option
processing. Note that unlike \fB\-version\fR, the prover will not terminate, but
proceed normally.
.HP
\fB\-\-error\-on\-empty\fR
.IP
Return with an error code if the input file contains no clauses.
Formally, the empty clause set (as an empty conjunction of clauses) is
trivially satisfiable, and E will treat any empty input set as
satisfiable. However, in composite systems this is more often a sign that
something went wrong. Use this option to catch such bugs.
.HP
\fB\-m\fR <arg>
.HP
\fB\-\-memory\-limit=\fR<arg>
.IP
Limit the memory the prover may use. The argument is the allowed amount
of memory in MB. If you use the argument 'Auto', the system will try to
figure out the amount of physical memory of your machine and claim most
of it. This option may not work everywhere, due to broken and/or strange
behaviour of setrlimit() in some UNIX implementations, and due to the
fact that I know of no portable way to figure out the physical memory in
a machine. Both the option and the 'Auto' version do work under all
tested versions of Solaris and GNU/Linux. Due to problems with limit data
types, it is currently impossible to set a limit of more than 2 GB (2048
MB).
.HP
\fB\-\-cpu\-limit[=\fR<arg>]
.IP
Limit the cpu time the prover should run. The optional argument is the
CPU time in seconds. The prover will terminate immediately after reaching
the time limit, regardless of internal state. This option may not work
everywhere, due to broken and/or strange behaviour of setrlimit() in some
UNIX implementations. It does work under all tested versions of Solaris,
HP\-UX, MacOS\-X, and GNU/Linux. As a side effect, this option will inhibit
core file writing. Please note that if you use both \fB\-\-cpu\-limit\fR and
\fB\-\-soft\-cpu\-limit\fR, the soft limit has to be smaller than the hard limit to
have any effect.  The option without the optional argument is equivalent
to \fB\-\-cpu\-limit\fR=\fI\,300\/\fR.
.HP
\fB\-\-soft\-cpu\-limit[=\fR<arg>]
.IP
Limit the cpu time the prover should spend in the main saturation phase.
The prover will then terminate gracefully, i.e. it will perform
post\-processing, filtering and printing of unprocessed clauses, if these
options are selected. Note that for some filtering options (in particular
those which perform full subsumption), the post\-processing time may well
be larger than the saturation time. This option is particularly useful if
you want to use E as a preprocessor or lemma generator in a larger
system. The option without the optional argument is equivalent to
\fB\-\-soft\-cpu\-limit\fR=\fI\,290\/\fR.
.HP
\fB\-R\fR
.HP
\fB\-\-resources\-info\fR
.IP
Give some information about the resources used by the prover. You will
usually get CPU time information. On systems returning more information
with the rusage() system call, you will also get information about memory
consumption.
.HP
\fB\-\-print\-strategy[=\fR<arg>]
.IP
Print a representation of all search parameters and their setting of a
given strategy, then terminate. If no argument is given, the current
strategy is printed. Use the reserved name '>all\-strats<'to get a
description of all built\-in strategies. The option without the optional
argument is equivalent to \fB\-\-print\-strategy=\fR>current\-strategy<.
.HP
\fB\-\-parse\-strategy=\fR<arg>
.IP
Parse the previously printed representation of strategy and set all proof
search parameters accordingly.
.HP
\fB\-C\fR <arg>
.HP
\fB\-\-processed\-clauses\-limit=\fR<arg>
.IP
Set the maximal number of clauses to process (i.e. the number of
traversals of the main\-loop).
.HP
\fB\-P\fR <arg>
.HP
\fB\-\-processed\-set\-limit=\fR<arg>
.IP
Set the maximal size of the set of processed clauses. This differs from
the previous option in that redundant and back\-simplified processed
clauses are not counted.
.HP
\fB\-U\fR <arg>
.HP
\fB\-\-unprocessed\-limit=\fR<arg>
.IP
Set the maximal size of the set of unprocessed clauses. This is a
termination condition, not something to use to control the deletion of
bad clauses. Compare \fB\-\-delete\-bad\-limit\fR.
.HP
\fB\-T\fR <arg>
.HP
\fB\-\-total\-clause\-set\-limit=\fR<arg>
.IP
Set the maximal size of the set of all clauses. See previous option.
.HP
\fB\-\-generated\-limit=\fR<arg>
.IP
Set the maximal number of generated clauses before the proof search
stops. This is a reasonable (though not great) estimate of the work done.
.HP
\fB\-\-tb\-insert\-limit=\fR<arg>
.IP
Set the maximal number of of term bank term top insertions. This is a
reasonable (though not great) estimate of the work done.
.HP
\fB\-\-answers[=\fR<arg>]
.IP
Set the maximal number of answers to print for existentially quantified
questions. Without this option, the prover terminates after the first
answer found. If the value is different from 1, the prover is no longer
guaranteed to terminate, even if there is a finite number of answers. The
option without the optional argument is equivalent to
\fB\-\-answers\fR=\fI\,2147483647\/\fR.
.HP
\fB\-\-conjectures\-are\-questions\fR
.IP
Treat all conjectures as questions to be answered. This is a wart
necessary because CASC\-J6 has categories requiring answers, but does not
yet support the 'question' type for formulas.
.HP
\fB\-n\fR
.HP
\fB\-\-eqn\-no\-infix\fR
.IP
In LOP, print equations in prefix notation equal(x,y).
.HP
\fB\-e\fR
.HP
\fB\-\-full\-equational\-rep\fR
.IP
In LOP. print all literals as equations, even non\-equational ones.
.HP
\fB\-\-lop\-in\fR
.IP
Set E\-LOP as the input format. If no input format is selected by this or
one of the following options, E will guess the input format based on the
first token. It will almost always correctly recognize TPTP\-3, but it may
misidentify E\-LOP files that use TPTP meta\-identifiers as logical
symbols.
.HP
\fB\-\-pcl\-out\fR
.IP
Set PCL as the proof object output format.
.HP
\fB\-\-tptp\-in\fR
.IP
Set TPTP\-2 as the input format (but note that includes are still handled
according to TPTP\-3 semantics).
.HP
\fB\-\-tptp\-out\fR
.IP
Print TPTP format instead of E\-LOP. Implies \fB\-\-eqn\-no\-infix\fR and will
ignore \fB\-\-full\-equational\-rep\fR.
.HP
\fB\-\-tptp\-format\fR
.IP
Equivalent to \fB\-\-tptp\-in\fR and \fB\-\-tptp\-out\fR.
.HP
\fB\-\-tptp2\-in\fR
.IP
Synonymous with \fB\-\-tptp\-in\fR.
.HP
\fB\-\-tptp2\-out\fR
.IP
Synonymous with \fB\-\-tptp\-out\fR.
.HP
\fB\-\-tptp2\-format\fR
.IP
Synonymous with \fB\-\-tptp\-format\fR.
.HP
\fB\-\-tstp\-in\fR
.IP
Set TPTP\-3 as the input format (Note that TPTP\-3 syntax is still under
development, and the version in E may not be fully conforming at all
times. E works on all TPTP 6.3.0 FOF and CNF files (including includes).
.HP
\fB\-\-tstp\-out\fR
.IP
Print output clauses in TPTP\-3 syntax. In particular, for output levels
>=2, write derivations as TPTP\-3 derivations.
.HP
\fB\-\-tstp\-format\fR
.IP
Equivalent to \fB\-\-tstp\-in\fR and \fB\-\-tstp\-out\fR.
.HP
\fB\-\-tptp3\-in\fR
.IP
Synonymous with \fB\-\-tstp\-in\fR.
.HP
\fB\-\-tptp3\-out\fR
.IP
Synonymous with \fB\-\-tstp\-out\fR.
.HP
\fB\-\-tptp3\-format\fR
.IP
Synonymous with \fB\-\-tstp\-format\fR.
.HP
\fB\-\-auto\fR
.IP
Automatically determine settings for proof search.
.HP
\fB\-\-auto\-schedule[=\fR<arg>]
.IP
Use the (experimental) strategy scheduling. This will try several
different fully specified search strategies (aka "Auto\-Modes"), one after
the other, until a proof or saturation is found, or the time limit is
exceeded. The optional argument is the number of CPUs on which the
schedule is going to be executed on. By default, the schedule is executed
on a single core. To execute on all cores of a system, set the argument
to 'Auto', but note that this will use all reported cores (even
low\-performance efficiency cores, if available on the hardware platform
and reported by the OS). The option without the optional argument is
equivalent to \fB\-\-auto\-schedule\fR=\fI\,1\/\fR.
.HP
\fB\-\-force\-preproc\-sched=\fR<arg>
.IP
When autoscheduling is used, make sure that preprocessing schedule is
inserted in the search categories
.HP
\fB\-\-serialize\-schedule=\fR<arg>
.IP
Convert parallel auto\-schedule into serialized one.
.HP
\fB\-\-satauto\-schedule[=\fR<arg>]
.IP
Use strategy scheduling without SInE, thus maintaining completeness. The
option without the optional argument is equivalent to
\fB\-\-satauto\-schedule\fR=\fI\,1\/\fR.
.HP
\fB\-\-no\-preprocessing\fR
.IP
Do not perform preprocessing on the initial clause set. Preprocessing
currently removes tautologies and orders terms, literals and clauses in a
certain ("canonical") way before anything else happens. Unless limited by
one of the following options, it will also unfold equational definitions.
.HP
\fB\-\-eq\-unfold\-limit=\fR<arg>
.IP
During preprocessing, limit unfolding (and removing) of equational
definitions to those where the expanded definition is at most the given
limit bigger (in terms of standard weight) than the defined term.
.HP
\fB\-\-eq\-unfold\-maxclauses=\fR<arg>
.IP
During preprocessing, don't try unfolding of equational definitions if
the problem has more than this limit of clauses.
.HP
\fB\-\-no\-eq\-unfolding\fR
.IP
During preprocessing, abstain from unfolding (and removing) equational
definitions.
.HP
\fB\-\-goal\-defs[=\fR<arg>]
.IP
Introduce Twee\-style equational definitions for ground terms in
conjecture clauses. The argument can be All or Neg, which will only
consider ground terms from negative literals (to be implemented). The
option without the optional argument is equivalent to \fB\-\-goal\-defs\fR=\fI\,All\/\fR.
.HP
\fB\-\-goal\-subterm\-defs\fR
.IP
Introduce goal definitions for all conjecture ground subterms. The
default is to only introduce them for the maximal (with respect to the
subterm relation) ground terms in conjecture clauses (to be implemented).
.HP
\fB\-\-sine[=\fR<arg>]
.IP
Apply SInE to prune the unprocessed axioms with the specified filter.
\&'Auto' will automatically pick a filter. The option without the optional
argument is equivalent to \fB\-\-sine\fR=\fI\,Auto\/\fR.
.HP
\fB\-\-rel\-pruning\-level[=\fR<arg>]
.IP
Perform relevancy pruning up to the given level on the unprocessed
axioms. The option without the optional argument is equivalent to
\fB\-\-rel\-pruning\-level\fR=\fI\,3\/\fR.
.HP
\fB\-\-presat\-simplify\fR
.IP
Before proper saturation do a complete interreduction of the proof state.
.HP
\fB\-\-ac\-handling[=\fR<arg>]
.IP
Select AC handling mode, i.e. determine what to do with redundant AC
tautologies. The default is equivalent to 'DiscardAll', the other
possible values are 'None' (to disable AC handling), 'KeepUnits', and
\&'KeepOrientable'. The option without the optional argument is equivalent
to \fB\-\-ac\-handling\fR=\fI\,KeepUnits\/\fR.
.HP
\fB\-\-ac\-non\-aggressive\fR
.IP
Do AC resolution on negative literals only on processing (by default, AC
resolution is done after clause creation). Only effective if AC handling
is not disabled.
.HP
\fB\-W\fR <arg>
.HP
\fB\-\-literal\-selection\-strategy=\fR<arg>
.IP
Choose a strategy for selection of negative literals. There are two
special values for this option: NoSelection will select no literal (i.e.
perform normal superposition) and NoGeneration will inhibit all
generating inferences. For a list of the other (hopefully
self\-documenting) values run 'eprover \fB\-W\fR none'. There are two variants of
each strategy. The one prefixed with 'P' will allow paramodulation into
maximal positive literals in addition to paramodulation into maximal
selected negative literals.
.HP
\fB\-\-no\-generation\fR
.IP
Don't perform any generating inferences (equivalent to
\fB\-\-literal\-selection\-strategy\fR=\fI\,NoGeneration\/\fR).
.HP
\fB\-\-select\-on\-processing\-only\fR
.IP
Perform literal selection at processing time only (i.e. select only in
the _given clause_), not before clause evaluation. This is relevant
because many clause selection heuristics give special consideration to
maximal or selected literals.
.HP
\fB\-i\fR
.HP
\fB\-\-inherit\-paramod\-literals\fR
.IP
Always select the negative literals a previous inference paramodulated
into (if possible). If no such literal exists, select as dictated by the
selection strategy.
.HP
\fB\-j\fR
.HP
\fB\-\-inherit\-goal\-pm\-literals\fR
.IP
In a goal (all negative clause), always select the negative literals a
previous inference paramodulated into (if possible). If no such literal
exists, select as dictated by the selection strategy.
.HP
\fB\-\-inherit\-conjecture\-pm\-literals\fR
.IP
In a conjecture\-derived clause, always select the negative literals a
previous inference paramodulated into (if possible). If no such literal
exists, select as dictated by the selection strategy.
.HP
\fB\-\-selection\-pos\-min=\fR<arg>
.IP
Set a lower limit for the number of positive literals a clause must have
to be eligible for literal selection.
.HP
\fB\-\-selection\-pos\-max=\fR<arg>
.IP
Set a upper limit for the number of positive literals a clause can have
to be eligible for literal selection.
.HP
\fB\-\-selection\-neg\-min=\fR<arg>
.IP
Set a lower limit for the number of negative literals a clause must have
to be eligible for literal selection.
.HP
\fB\-\-selection\-neg\-max=\fR<arg>
.IP
Set a upper limit for the number of negative literals a clause can have
to be eligible for literal selection.
.HP
\fB\-\-selection\-all\-min=\fR<arg>
.IP
Set a lower limit for the number of literals a clause must have to be
eligible for literal selection.
.HP
\fB\-\-selection\-all\-max=\fR<arg>
.IP
Set an upper limit for the number of literals a clause must have to be
eligible for literal selection.
.HP
\fB\-\-selection\-weight\-min=\fR<arg>
.IP
Set the minimum weight a clause must have to be eligible for literal
selection.
.HP
\fB\-\-prefer\-initial\-clauses\fR
.IP
Always process all initial clauses first.
.HP
\fB\-x\fR <arg>
.HP
\fB\-\-expert\-heuristic=\fR<arg>
.IP
Select one of the clause selection heuristics. Currently at least
available: Auto, Weight, StandardWeight, RWeight, FIFO, LIFO, Uniq,
UseWatchlist. For a full list check HEURISTICS/che_proofcontrol.c. Auto
is recommended if you only want to find a proof. It is special in that it
will also set some additional options. To have optimal performance, you
also should specify \fB\-tAuto\fR to select a good term ordering. LIFO is unfair
and will make the prover incomplete. Uniq is used internally and is not
very useful in most cases. You can define more heuristics using the
option \fB\-H\fR (see below).
.HP
\fB\-\-filter\-orphans\-limit[=\fR<arg>]
.IP
Orphans are unprocessed clauses where one of the parents has been removed
by back\-simolification. They are redundant and usually removed lazily
(i.e. only when they are selected for processing). With this option you
can select a limit on back\-simplified clauses  after which orphans will
be eagerly deleted. The option without the optional argument is
equivalent to \fB\-\-filter\-orphans\-limit\fR=\fI\,100\/\fR.
.HP
\fB\-\-forward\-contract\-limit[=\fR<arg>]
.IP
Set a limit on the number of processed clauses after which the
unprocessed clause set will be re\-simplified and reweighted.  The option
without the optional argument is equivalent to
\fB\-\-forward\-contract\-limit\fR=\fI\,80000\/\fR.
.HP
\fB\-\-delete\-bad\-limit[=\fR<arg>]
.IP
Set the number of storage units after which bad clauses are deleted
without further consideration. This causes the prover to be potentially
incomplete, but will allow you to limit the maximum amount of memory used
fairly well. The prover will tell you if a proof attempt failed due to
the incompleteness introduced by this option. It is recommended to set
this limit significantly higher than \fB\-\-filter\-limit\fR or
\fB\-\-filter\-copies\-limit\fR. If you select \fB\-xAuto\fR and set a memory limit, the
prover will determine a good value automatically. The option without the
optional argument is equivalent to \fB\-\-delete\-bad\-limit\fR=\fI\,1500000\/\fR.
.HP
\fB\-\-assume\-completeness\fR
.IP
There are various way (e.g. the next few options) to configure the prover
to be strongly incomplete in the general case. E will detect when such an
option is selected and return corresponding exit states (i.e. it will not
claim satisfiability just because it ran out of unprocessed clauses). If
you _know_ that for your class of problems the selected strategy is still
complete, use this option to tell the system that this is the case.
.HP
\fB\-\-assume\-incompleteness\fR
.IP
This option instructs the prover to assume incompleteness (typically
because the axiomatization already is incomplete because axioms have been
filtered before they are handed to the system.
.HP
\fB\-\-disable\-eq\-factoring\fR
.IP
Disable equality factoring. This makes the prover incomplete for general
non\-Horn problems, but helps for some specialized classes. It is not
necessary to disable equality factoring for Horn problems, as Horn
clauses are not factored anyways.
.HP
\fB\-\-disable\-paramod\-into\-neg\-units\fR
.IP
Disable paramodulation into negative unit clause. This makes the prover
incomplete in the general case, but helps for some specialized classes.
.HP
\fB\-\-condense\fR
.IP
Enable condensing for the given clause. Condensing replaces a clause by a
more general factor (if such a factor exists).
.HP
\fB\-\-condense\-aggressive\fR
.IP
Enable condensing for the given and newly generated clauses.
.HP
\fB\-\-disable\-given\-clause\-fw\-contraction\fR
.IP
Disable simplification and subsumption of the newly selected given clause
(clauses are still simplified when they are generated). In general, this
breaks some basic assumptions of the DISCOUNT loop proof search
procedure. However, there are some problem classes in which  this
simplifications empirically never occurs. In such cases, we can save
significant overhead. The option _should_ work in all cases, but is not
expected to improve things in most cases.
.HP
\fB\-\-simul\-paramod\fR
.IP
Use simultaneous paramodulation to implement superposition. Default is to
use plain paramodulation.
.HP
\fB\-\-oriented\-simul\-paramod\fR
.IP
Use simultaneous paramodulation for oriented from\-literals. This is an
experimental feature.
.HP
\fB\-\-supersimul\-paramod\fR
.IP
Use supersimultaneous paramodulation to implement superposition. Default
is to use plain paramodulation.
.HP
\fB\-\-oriented\-supersimul\-paramod\fR
.IP
Use supersimultaneous paramodulation for oriented from\-literals. This is
an experimental feature.
.HP
\fB\-\-split\-clauses[=\fR<arg>]
.IP
Determine which clauses should be subject to splitting. The argument is
the binary 'OR' of values for the desired classes:
.TP
1:
Horn clauses
.TP
2:
Non\-Horn clauses
.TP
4:
Negative clauses
.TP
8:
Positive clauses
.TP
16:
Clauses with both positive and negative literals
.IP
Each set bit adds that class to the set of clauses which will be split.
The option without the optional argument is equivalent to
\fB\-\-split\-clauses\fR=\fI\,7\/\fR.
.HP
\fB\-\-split\-method=\fR<arg>
.IP
Determine how to treat ground literals in splitting. The argument is
either '0' to denote no splitting of ground literals (they are all
assigned to the first split clause produced), '1' to denote that all
ground literals should form a single new clause, or '2', in which case
ground literals are treated as usual and are all split off into
individual clauses.
.HP
\fB\-\-split\-aggressive\fR
.IP
Apply splitting to new clauses (after simplification) and before
evaluation. By default, splitting (if activated) is only performed on
selected clauses.
.HP
\fB\-\-split\-reuse\-defs\fR
.IP
If possible, reuse previous definitions for splitting.
.HP
\fB\-\-disequality\-decomposition[=\fR<arg>]
.IP
Enable the disequality decomposition inference. The optional argument is
the maximal literal number of clauses considered for the inference. The
option without the optional argument is equivalent to
\fB\-\-disequality\-decomposition\fR=\fI\,1024\/\fR.
.HP
\fB\-\-disequality\-decomp\-maxarity[=\fR<arg>]
.IP
Limit disequality decomposition to function symbols of at most the given
arity. The option without the optional argument is equivalent to
\fB\-\-disequality\-decomp\-maxarity\fR=\fI\,1\/\fR.
.HP
\fB\-t\fR <arg>
.HP
\fB\-\-term\-ordering=\fR<arg>
.IP
Select an ordering type (currently Auto, LPO, LPO4, KBO or KBO6). \fB\-tAuto\fR
is suggested, in particular with \fB\-xAuto\fR. KBO and KBO6 are different
implementations of the same ordering, KBO6 is usually faster and has had
more testing. Similarly, LPO4 is a new, equivalent but superior
implementation of LPO.
.HP
\fB\-w\fR <arg>
.HP
\fB\-\-order\-weight\-generation=\fR<arg>
.IP
Select a method for the generation of weights for use with the term
ordering. Run 'eprover \fB\-w\fR none' for a list of options.
.HP
\fB\-\-order\-weights=\fR<arg>
.IP
Describe a (partial) assignments of weights to function symbols for term
orderings (in particular, KBO). You can specify a list of weights of the
form 'f1:w1,f2:w2, ...'. Since a total weight assignment is needed, E
will _first_ apply any weight generation scheme specified (or the default
one), and then modify the weights as specified. Note that E performs only
very basic sanity checks, so you probably can specify weights that break
KBO constraints.
.HP
\fB\-G\fR <arg>
.HP
\fB\-\-order\-precedence\-generation=\fR<arg>
.IP
Select a method for the generation of a precedence for use with the term
ordering. Run 'eprover \fB\-G\fR none' for a list of options.
.HP
\fB\-\-prec\-pure\-conj[=\fR<arg>]
.IP
Set a weight for symbols that occur in conjectures only to determinewhere
to place it in the precedence. This value is used for a roughpre\-order,
the normal schemes only sort within symbols with the sameoccurrence
modifier. The option without the optional argument is equivalent to
\fB\-\-prec\-pure\-conj\fR=\fI\,10\/\fR.
.HP
\fB\-\-prec\-conj\-axiom[=\fR<arg>]
.IP
Set a weight for symbols that occur in both conjectures and axiomsto
determine where to place it in the precedence. This value is used for a
rough pre\-order, the normal schemes only sort within symbols with the
same occurrence modifier. The option without the optional argument is
equivalent to \fB\-\-prec\-conj\-axiom\fR=\fI\,5\/\fR.
.HP
\fB\-\-prec\-pure\-axiom[=\fR<arg>]
.IP
Set a weight for symbols that occur in axioms only to determine where to
place it in the precedence. This value is used for a rough pre\-order, the
normal schemes only sort within symbols with the same occurrence
modifier. The option without the optional argument is equivalent to
\fB\-\-prec\-pure\-axiom\fR=\fI\,2\/\fR.
.HP
\fB\-\-prec\-skolem[=\fR<arg>]
.IP
Set a weight for Skolem symbols to determine where to place it in the
precedence. This value is used for a rough pre\-order, the normal schemes
only sort within symbols with the same occurrence modifier. The option
without the optional argument is equivalent to \fB\-\-prec\-skolem\fR=\fI\,2\/\fR.
.HP
\fB\-\-prec\-defpred[=\fR<arg>]
.IP
Set a weight for introduced predicate symbols (usually via definitional
CNF or clause splitting) to determine where to place it in the
precedence. This value is used for a rough pre\-order, the normal schemes
only sort within symbols with the same occurrence modifier. The option
without the optional argument is equivalent to \fB\-\-prec\-defpred\fR=\fI\,2\/\fR.
.HP
\fB\-c\fR <arg>
.HP
\fB\-\-order\-constant\-weight=\fR<arg>
.IP
Set a special weight > 0 for constants in the term ordering. By default,
constants are treated like other function symbols.
.HP
\fB\-\-precedence[=\fR<arg>]
.IP
Describe a (partial) precedence for the term ordering used for the proof
attempt. You can specify a comma\-separated list of precedence chains,
where a precedence chain is a list of function symbols (which all have to
appear in the proof problem), connected by >, <, or =. If this option is
used in connection with \fB\-\-order\-precedence\-generation\fR, the partial
ordering will be completed using the selected method, otherwise the
prover runs with a non\-ground\-total ordering. The option without the
optional argument is equivalent to \fB\-\-precedence=\fR.
.HP
\fB\-\-lpo\-recursion\-limit[=\fR<arg>]
.IP
Set a depth limit for LPO comparisons. Most comparisons do not need more
than 10 or 20 levels of recursion. By default, recursion depth is limited
to 1000 to avoid stack overflow problems. If the limit is reached, the
prover assumes that the terms are uncomparable. Smaller values make the
comparison attempts faster, but less exact. Larger values have the
opposite effect. Values up to 20000 should be save on most operating
systems. If you run into segmentation faults while using LPO or LPO4,
first try to set this limit to a reasonable value. If the problem
persists, send a bug report ;\-) The option without the optional argument
is equivalent to \fB\-\-lpo\-recursion\-limit\fR=\fI\,100\/\fR.
.HP
\fB\-\-restrict\-literal\-comparisons\fR
.IP
Make all literals uncomparable in the term ordering (i.e. do not use the
term ordering to restrict paramodulation, equality resolution and
factoring to certain literals. This is necessary to make
Set\-of\-Support\-strategies complete for the non\-equational case (It still
is incomplete for the equational case, but pretty useless anyways).
.HP
\fB\-\-literal\-comparison=\fR<arg>
.IP
Modify how literal comparisons are done. 'None' is equivalent to the
previous option, 'Normal' uses the normal lifting of the term ordering,
\&'TFOEqMax' uses the equivalent of a transfinite ordering deciding on the
predicate symbol and making equational literals maximal (note that this
setting makes the prover incomplere), and 'TFOEqMin' modifies this by
making equational symbols minimal.
.HP
\fB\-\-sos\-uses\-input\-types\fR
.IP
If input is TPTP format, use TPTP conjectures for initializing the Set of
Support. If not in TPTP format, use E\-LOP queries (clauses of the form
?\-l(X),...,m(Y)). Normally, all negative clauses are used. Please note
that most E heuristics do not use this information at all, it is
currently only useful for certain parameter settings (including the
SimulateSOS priority function).
.HP
\fB\-\-destructive\-er\fR
.IP
Allow destructive equality resolution inferences on pure\-variable
literals of the form X!=Y, i.e. replace the original clause with the
result of an equality resolution inference on this literal.
.HP
\fB\-\-strong\-destructive\-er\fR
.IP
Allow destructive equality resolution inferences on literals of the form
X!=t (where X does not occur in t), i.e. replace the original clause with
the result of an equality resolution inference on this literal. Unless I
am brain\-dead, this maintains completeness, although the proof is rather
tricky.
.HP
\fB\-\-destructive\-er\-aggressive\fR
.IP
Apply destructive equality resolution to all newly generated clauses, not
just to selected clauses. Implies \fB\-\-destructive\-er\fR.
.HP
\fB\-\-forward\-context\-sr\fR
.IP
Apply contextual simplify\-reflect with processed clauses to the given
clause.
.HP
\fB\-\-forward\-context\-sr\-aggressive\fR
.IP
Apply contextual simplify\-reflect with processed clauses to new clauses.
Implies \fB\-\-forward\-context\-sr\fR.
.HP
\fB\-\-backward\-context\-sr\fR
.IP
Apply contextual simplify\-reflect with the given clause to processed
clauses.
.HP
\fB\-g\fR
.HP
\fB\-\-prefer\-general\-demodulators\fR
.IP
Prefer general demodulators. By default, E prefers specialized
demodulators. This affects in which order the rewrite  index is
traversed.
.HP
\fB\-F\fR <arg>
.HP
\fB\-\-forward\-demod\-level=\fR<arg>
.IP
Set the desired level for rewriting of unprocessed clauses. A value of 0
means no rewriting, 1 indicates to use rules (orientable equations) only,
2 indicates full rewriting with rules and instances of unorientable
equations. Default behavior is 2.
.HP
\fB\-\-demod\-under\-lambda=\fR<arg>
.IP
Demodulate *closed* subterms under lambdas.
.HP
\fB\-\-strong\-rw\-inst\fR
.IP
Instantiate unbound variables in matching potential demodulators with a
small constant terms.
.HP
\fB\-u\fR
.HP
\fB\-\-strong\-forward\-subsumption\fR
.IP
Try multiple positions and unit\-equations to try to equationally subsume
a single new clause. Default is to search for a single position.
.HP
\fB\-\-satcheck\-proc\-interval[=\fR<arg>]
.IP
Enable periodic SAT checking at the given interval of main loop
non\-trivial processed clauses. The option without the optional argument
is equivalent to \fB\-\-satcheck\-proc\-interval\fR=\fI\,5000\/\fR.
.HP
\fB\-\-satcheck\-gen\-interval[=\fR<arg>]
.IP
Enable periodic SAT checking whenever the total proof state size
increases by the given limit. The option without the optional argument is
equivalent to \fB\-\-satcheck\-gen\-interval\fR=\fI\,10000\/\fR.
.HP
\fB\-\-satcheck\-ttinsert\-interval[=\fR<arg>]
.IP
Enable periodic SAT checking whenever the number of term tops insertions
matches the given limit (which grows exponentially). The option without
the optional argument is equivalent to
\fB\-\-satcheck\-ttinsert\-interval\fR=\fI\,5000000\/\fR.
.HP
\fB\-\-satcheck[=\fR<arg>]
.IP
Set the grounding strategy for periodic SAT checking. Note that to enable
SAT checking, it is also necessary to set the interval with one of the
previous two options. The option without the optional argument is
equivalent to \fB\-\-satcheck\fR=\fI\,FirstConst\/\fR.
.HP
\fB\-\-satcheck\-decision\-limit[=\fR<arg>]
.IP
Set the number of decisions allowed for each run of the SAT solver. If
the option is not given, the built\-in value is 10000. Use \fB\-1\fR to allow
unlimited decision. The option without the optional argument is
equivalent to \fB\-\-satcheck\-decision\-limit\fR=\fI\,100\/\fR.
.HP
\fB\-\-satcheck\-normalize\-const\fR
.IP
Use the current normal form (as recorded in the termbank rewrite cache)
of the selected constant as the term for the grounding substitution.
.HP
\fB\-\-satcheck\-normalize\-unproc\fR
.IP
Enable re\-simplification (heuristic re\-revaluation) of unprocessed
clauses before grounding for SAT checking.
.HP
\fB\-\-watchlist[=\fR<arg>]
.IP
Give the name for a file containing clauses to be watched for during the
saturation process. If a clause is generated that subsumes a watchlist
clause, the subsumed clause is removed from the watchlist. The prover
will terminate when the watchlist is empty. If you want to use the
watchlist for guiding the proof, put the empty clause onto the list and
use the built\-in clause selection heuristic 'UseWatchlist' (or build a
heuristic yourself using the priority functions 'PreferWatchlist' and
\&'DeferWatchlist'). Use the argument 'Use inline watchlist type' (or no
argument) and the special clause type 'watchlist' if you want to put
watchlist clauses into the normal input stream. This is only supported
for TPTP input formats. The option without the optional argument is
equivalent to \fB\-\-watchlist=\fR'Use inline watchlist type'.
.HP
\fB\-\-static\-watchlist[=\fR<arg>]
.IP
This is identical to the previous option, but subsumed clauses willnot be
removed from the watchlist (and hence the prover will not terminate if
all watchlist clauses have been subsumed. This may be more useful for
heuristic guidance. The option without the optional argument is
equivalent to \fB\-\-static\-watchlist=\fR'Use inline watchlist type'.
.HP
\fB\-\-no\-watchlist\-simplification\fR
.IP
By default, the watchlist is brought into normal form with respect to the
current processed clause set and certain simplifications. This option
disables simplification for the watchlist.
.HP
\fB\-\-fw\-subsumption\-aggressive\fR
.IP
Perform forward subsumption on newly generated clauses before they are
evaluated. This is particularly useful if heuristic evaluation is very
expensive, e.g. via externally connected neural networks.
.HP
\fB\-\-conventional\-subsumption\fR
.IP
Equivalent to \fB\-\-subsumption\-indexing\fR=\fI\,None\/\fR.
.HP
\fB\-\-subsumption\-indexing=\fR<arg>
.IP
Determine choice of indexing for (most) subsumption operations. Choices
are 'None' for naive subsumption, 'Direct' for direct mapped FV\-Indexing,
\&'Perm' for permuted FV\-Indexing and 'PermOpt' for permuted FV\-Indexing
with deletion of (suspected) non\-informative features. Default behaviour
is 'Perm'.
.HP
\fB\-\-fvindex\-featuretypes=\fR<arg>
.IP
Select the feature types used for indexing. Choices are "None" to disable
FV\-indexing, "AC" for AC compatible features (the default) (literal
number and symbol counts), "SS" for set subsumption compatible features
(symbol depth), and "All" for all features.Unless you want to measure the
effects of the different features, I suggest you stick with the default.
.HP
\fB\-\-fvindex\-maxfeatures[=\fR<arg>]
.IP
Set the maximum initial number of symbols for feature computation.
Depending on the feature selection, a value of X here will convert into
2X+2 features (for set subsumption features), 2X+4 features (for
AC\-compatible features) or 4X+6 features (if all features are used, the
default). Note that the actually used set of features may be smaller than
this if the signature does not contain enough symbols.For the Perm and
PermOpt version, this is _also_ used to set the maximum depth of the
feature vector index. Yes, I should probably make this into two separate
options. If you select a small value here, you should probably not use
"Direct" for the \fB\-\-subsumption\-indexing\fR option. The option without the
optional argument is equivalent to \fB\-\-fvindex\-maxfeatures\fR=\fI\,200\/\fR.
.HP
\fB\-\-fvindex\-slack[=\fR<arg>]
.IP
Set the number of slots reserved in the index for function symbols that
may be introduced into the signature later, e.g. by splitting. If no new
symbols are introduced, this just wastes time and memory. If PermOpt is
chosen, the slackness slots will be deleted from the index anyways, but
will still waste (a little) time in computing feature vectors. The option
without the optional argument is equivalent to \fB\-\-fvindex\-slack\fR=\fI\,0\/\fR.
.HP
\fB\-\-rw\-bw\-index[=\fR<arg>]
.IP
Select fingerprint function for backwards rewrite index. "NoIndex" will
disable paramodulation indexing. For a list of the other values run
\&'eprover \fB\-\-pm\-index\fR=\fI\,none\/\fR'. FPX functions will use a fingerprint of X
positions, the letters disambiguate between different fingerprints with
the same sample size. The option without the optional argument is
equivalent to \fB\-\-rw\-bw\-index\fR=\fI\,FP7\/\fR.
.HP
\fB\-\-pm\-from\-index[=\fR<arg>]
.IP
Select fingerprint function for the index for paramodulation from indexed
clauses. "NoIndex" will disable paramodulation indexing. For a list of
the other values run 'eprover \fB\-\-pm\-index\fR=\fI\,none\/\fR'. FPX functionswill use a
fingerprint of X positions, the letters disambiguate between different
fingerprints with the same sample size. The option without the optional
argument is equivalent to \fB\-\-pm\-from\-index\fR=\fI\,FP7\/\fR.
.HP
\fB\-\-pm\-into\-index[=\fR<arg>]
.IP
Select fingerprint function for the index for paramodulation into the
indexed clauses. "NoIndex" will disable paramodulation indexing. For a
list of the other values run 'eprover \fB\-\-pm\-index\fR=\fI\,none\/\fR'. FPX functionswill
use a fingerprint of X positions, the letters disambiguate between
different fingerprints with the same sample size. The option without the
optional argument is equivalent to \fB\-\-pm\-into\-index\fR=\fI\,FP7\/\fR.
.HP
\fB\-\-fp\-index[=\fR<arg>]
.IP
Select fingerprint function for all fingerprint indices. See above. The
option without the optional argument is equivalent to \fB\-\-fp\-index\fR=\fI\,FP7\/\fR.
.HP
\fB\-\-fp\-no\-size\-constr\fR
.IP
Disable usage of size constraints for matching with fingerprint indexing.
.HP
\fB\-\-pdt\-no\-size\-constr\fR
.IP
Disable usage of size constraints for matching with perfect
discrimination trees indexing.
.HP
\fB\-\-pdt\-no\-age\-constr\fR
.IP
Disable usage of age constraints for matching with perfect discrimination
trees indexing.
.HP
\fB\-\-detsort\-rw\fR
.IP
Sort set of clauses eliminated by backward rewriting using a total
syntactic ordering.
.HP
\fB\-\-detsort\-new\fR
.IP
Sort set of newly generated and backward simplified clauses using a total
syntactic ordering.
.HP
\fB\-D\fR <arg>
.HP
\fB\-\-define\-weight\-function=\fR<arg>
.TP
Define
a weight function (see manual for details). Later definitions
.IP
override previous definitions.
.HP
\fB\-H\fR <arg>
.HP
\fB\-\-define\-heuristic=\fR<arg>
.IP
Define a clause selection heuristic (see manual for details). Later
definitions override previous definitions.
.HP
\fB\-\-free\-numbers\fR
.IP
Treat numbers (strings of decimal digits) as normal free function symbols
in the input. By default, number now are supposed to denote domain
constants and to be implicitly different from each other.
.HP
\fB\-\-free\-objects\fR
.IP
Treat object identifiers (strings in double quotes) as normal free
function symbols in the input. By default, object identifiers now
represent domain objects and are implicitly different from each other
(and from numbers, unless those are declared to be free).
.HP
\fB\-\-definitional\-cnf[=\fR<arg>]
.IP
Tune the clausification algorithm to introduces definitions for
subformulae to avoid exponential blow\-up. The optional argument is a
fudge factor that determines when definitions are introduced. 0 disables
definitions completely. The default works well. The option without the
optional argument is equivalent to \fB\-\-definitional\-cnf\fR=\fI\,24\/\fR.
.HP
\fB\-\-fool\-unroll=\fR<arg>
.IP
Enable or disable FOOL unrolling. Useful for some SH problems.
.HP
\fB\-\-old\-cnf[=\fR<arg>]
.IP
As the previous option, but use the classical, well\-tested clausification
algorithm as opposed to the newewst one which avoides some algorithmic
pitfalls and hence works better on some exotic formulae. The two may
produce slightly different (but equisatisfiable) clause normal forms. The
option without the optional argument is equivalent to \fB\-\-old\-cnf\fR=\fI\,24\/\fR.
.HP
\fB\-\-miniscope\-limit[=\fR<arg>]
.IP
Set the limit of sub\-formula\-size to miniscope. The build\-indefault is
256. Only applies to the new (default) clausification algorithm The
option without the optional argument is equivalent to
\fB\-\-miniscope\-limit\fR=\fI\,2147483648\/\fR.
.HP
\fB\-\-print\-types\fR
.IP
Print the type of every term. Useful for debugging purposes.
.HP
\fB\-\-app\-encode\fR
.IP
Encodes terms in the proof state using applicative encoding, prints
encoded input problem and exits.
.HP
\fB\-\-arg\-cong=\fR<arg>
.IP
Turns on ArgCong inference rule. Excepts an argument "all" or "max" that
applies the rule to all or only literals that are eligible for
resolution.
.HP
\fB\-\-neg\-ext=\fR<arg>
.IP
Turns on NegExt inference rule. Excepts an argument "all" or "max" that
applies the rule to all or only literals that are eligible for
resolution.
.HP
\fB\-\-pos\-ext=\fR<arg>
.IP
Turns on PosExt inference rule. Excepts an argument "all" or "max" that
applies the rule to all or only literals that are eligible for
resolution.
.HP
\fB\-\-ext\-sup\-max\-depth=\fR<arg>
.IP
Sets the maximal proof depth of the clause which will be considered for
Ext\-family of inferences. Negative value disables the rule.
.HP
\fB\-\-inverse\-recognition\fR
.IP
Enables the recognition of injective function symbols. If such a symbol
is recognized, existence of the inverse function is asserted by adding a
corresponding axiom.
.HP
\fB\-\-replace\-inj\-defs\fR
.IP
After CNF and before saturation, replaces all clauses that are
definitions  of injectivity by axiomatization of inverse function.
.HP
\fB\-\-lift\-lambdas=\fR<arg>
.IP
Should the lambdas be replaced by named fuctions?
.HP
\fB\-\-eta\-normalize=\fR<arg>
.IP
Which form of eta normalization to perform?
.HP
\fB\-\-ho\-order\-kind=\fR<arg>
.IP
Do we use simple LFHO order or a more advanced Boolean free lambda\-KBO?
.HP
\fB\-\-cnf\-lambda\-to\-forall=\fR<arg>
.IP
Do we turn equations of the form ^X.s (!)= ^X.t into (?)!X. s (!)= t ?
.HP
\fB\-\-kbo\-lam\-weight=\fR<arg>
.IP
Weight of lambda symbol in KBO.
.HP
\fB\-\-kbo\-db\-weight=\fR<arg>
.IP
Weight of DB var in KBO.
.HP
\fB\-\-eliminate\-leibniz\-eq=\fR<arg>
.IP
Maximal proof depth of the clause on which Leibniz equality elimination
should be applied; \fB\-1\fR disaables Leibniz equality elimination altogether
.HP
\fB\-\-unroll\-formulas\-only=\fR<arg>
.IP
Set to true if you want only formulas to be recognized as definitions
during CNF. Default is true.
.HP
\fB\-\-prim\-enum\-mode=\fR<arg>
.IP
Choose the mode of primitive enumeration
.HP
\fB\-\-prim\-enum\-max\-depth=\fR<arg>
.IP
Maximal proof depth of a clause on which primitive enumeration is
applied. \fB\-1\fR disables primitive enumeration
.HP
\fB\-\-inst\-choice\-max\-depth=\fR<arg>
.IP
Maximal proof depth of a clause which is going to be scanned for
occurrences of defined choice symbol \fB\-1\fR disables scanning for choice
symbols
.HP
\fB\-\-local\-rw=\fR<arg>
.TP
Enable/disable local rewriting: if the clause is of the form s != t |
C,
.IP
where s > t, rewrite all occurrences of s with t in C.
.HP
\fB\-\-prune\-args=\fR<arg>
.IP
Enable/disable pruning arguments of applied variables.
.HP
\fB\-\-func\-proj\-limit=\fR<arg>
.IP
Maximal number of functional projections
.HP
\fB\-\-imit\-limit=\fR<arg>
.IP
Maximal number of imitations
.HP
\fB\-\-ident\-limit=\fR<arg>
.IP
Maximal number of identifications
.HP
\fB\-\-elim\-limit=\fR<arg>
.IP
Maximal number of eliminations
.HP
\fB\-\-unif\-mode=\fR<arg>
.IP
Set the mode of unification: either single or multi.
.HP
\fB\-\-pattern\-oracle=\fR<arg>
.IP
Turn the pattern oracle on or off.
.HP
\fB\-\-fixpoint\-oracle=\fR<arg>
.IP
Turn the pattern oracle on or off.
.HP
\fB\-\-max\-unifiers=\fR<arg>
.IP
Maximal number of imitations
.HP
\fB\-\-max\-unif\-steps=\fR<arg>
.IP
Maximal number of variable bindings that can be done in one single call
to copmuting the next unifier.
.HP
\fB\-\-classification\-timeout\-portion=\fR<arg>
.IP
Which percentage (from 1 to 99) of the total CPU time will be devoted to
problem classification?
.HP
\fB\-\-preinstantiate\-induction=\fR<arg>
.IP
Abstract unit clauses coming from conjecture and use the abstractions to
instantiate clauses that look like the ones coming from induction axioms.
.HP
\fB\-\-bce=\fR<arg>
.IP
Turn blocked clause elimination on or off
.HP
\fB\-\-bce\-max\-occs=\fR<arg>
.IP
Stop tracking symbol after it occurs in <arg> clauses Set <arg> to \fB\-1\fR
disable this limit
.HP
\fB\-\-pred\-elim=\fR<arg>
.IP
Turn predicate elimination on or off
.HP
\fB\-\-pred\-elim\-max\-occs=\fR<arg>
.IP
Stop tracking symbol after it occurs in <arg> clauses Set <arg> to \fB\-1\fR
disable this limit
.HP
\fB\-\-pred\-elim\-tolerance=\fR<arg>
.IP
Tolerance for predicate elimination measures.
.HP
\fB\-\-pred\-elim\-recognize\-gates=\fR<arg>
.IP
Turn gate recognition for predicate elimination on or off
.HP
\fB\-\-pred\-elim\-force\-mu\-decrease=\fR<arg>
.IP
Require that the square number of distinct free variables decreases when
doing predicate elimination. Helps avoid creating huge clauses.
.HP
\fB\-\-pred\-elim\-ignore\-conj\-syms=\fR<arg>
.IP
Disable eliminating symbols that occur in the conjecture.
.SH "REPORTING BUGS"
.PP
Report bugs to <schulz@eprover.org>. Please include the following, if
possible:
.PP
* The version of the package as reported by \fBeprover \-\-version\fR.
.PP
* The operating system and version.
.PP
* The exact command line that leads to the unexpected behaviour.
.PP
* A description of what you expected and what actually happened.
.PP
* If possible all input files necessary to reproduce the bug.
.SH COPYRIGHT
Copyright 1998\-2024 by Stephan Schulz, schulz@eprover.org,
and the E contributors (see DOC/CONTRIBUTORS).
.PP
This program is a part of the distribution of the equational theorem
prover E. You can find the latest version of the E distribution
as well as additional information at
http://www.eprover.org
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
.PP
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
.PP
You should have received a copy of the GNU General Public License
along with this program (it should be contained in the top level
directory of the distribution in the file COPYING); if not, write to
the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
Boston, MA  02111\-1307 USA
.PP
The original copyright holder can be contacted via email or as
.PP
Stephan Schulz
DHBW Stuttgart
Fakultaet Technik
Informatik
Lerchenstrasse 1
70174 Stuttgart
Germany
